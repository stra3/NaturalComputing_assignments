<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../">
  <title data-ice="title">Manual | Artistoo</title>
  
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">

  <script src="../misc/nav.js"></script>
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css" integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T" crossorigin="anonymous">
     <script src="https://code.jquery.com/jquery-3.4.1.slim.min.js" integrity="sha384-J6qa4849blE2+poT4WnyKhv5vZF5SrPo0iEjwBvKU7imGFAV0wwj1yYfoRSJoZ+n" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.16.0/dist/umd/popper.min.js" integrity="sha384-Q6E9RHvbIyZFJoft+2mJbHaEWldlvI9IOYy5n3zV9zzTtmI3UksdQRVvoxMfooAo" crossorigin="anonymous"></script>
    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.4.1/js/bootstrap.min.js" integrity="sha384-wfSDF2E50Y2D1uUdj0O3uMBJnjuUD4Ih7YwaYd1iqfktj0Uod8GCExl3Og8ifwB6" crossorigin="anonymous"></script>

<script>
MathJax = {
	tex: {
		inlineMath: [['$', '$']]
	}
};
</script>
<script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body class="layout-container manual-root manual-index" data-ice="rootContainer">

<style>
/*.li {
	list-style-type: none!important;
}*/

.navbar{
padding-left:10px;
padding-right:10px;
}


.mainimg {
	min-height: 21em;
    background-color: #666;
    margin:0px 0px!important; padding:0px!important;
	background-position: center;
    background-image:linear-gradient(rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.9)), 
    url('../misc/cpm-01.jpg');
}
.mainimg h1 {
  margin-bottom: 10px;
  font-size: 34px;
  font-weight: 300;
  border-bottom: solid 0px #ddd;
  text-align: center;
  font-size: 400%;
}

.mainimg h2 {
	text-align: center;
	font-size:200%;
	border-bottom: solid 0px;
}

.front-page h1 {
	border-bottom: solid 0px;
	margin-top:30px;
	margin-bottom:20px;
}

.front-page h2 {
	border-bottom: solid 0px;
	margin-top:30px;
	font-size:170%!important;
}


.bottom {
  display: block;
  position: absolute;
   bottom: 0;
}
</style>


<nav class="navbar navbar-toggleable navbar-expand-lg fixed-top navbar-light bg-light" id="navbar-main" style="border-bottom: solid 1px #ddd;">
    <div class="container" style="margin-left:0px;max-width:100%;">
        <a class="navbar-brand" href="index.html">Home</a>
		<button class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
    		<span class="navbar-toggler-icon"></span>
  		</button>
    	<div class="collapse navbar-collapse" id="navbarNav">
		  	<ul class="navbar-nav mr-auto">
				<li class="nav-item" style="list-style-type: none!important;">
				  <a class="nav-link" href="examples.html"><span>Examples</span></a>
				</li>

				<li class="nav-item">
				  <a class="nav-link" href="./manual/index.html"><span>Manual</span></a>
				</li>

				<li class="nav-item">
					<a class="nav-link" href="identifiers.html"><span>Documentation</span></a>
				</li>
				<li class="nav-item" style="list-style-type: none!important;">
				  <a class="nav-link" href="converter.html"><span>Converter</span></a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="source.html"><span>Source</span></a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="test.html"><span>Tests</span></a>
				</li>
				<li class="nav-item">
					<a class="nav-link" href="https://github.com/ingewortel/artistoo"><img width="20px" style="position:relative;top:-2px;" src="./image/github.png"></a>
				</li>
			</ul>
			<div class="search-box">
				  <span>
					<img src="./image/search.png">
					<span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
				  </span>
					<ul class="search-result"></ul>
				  </div>
			</div>
			  
    	</div>
    	
</nav>

<nav class="navigation" data-ice="nav" id="mySidepanel"><div class="manual-toc-root">
  
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/installation.html"><a href="manual/installation.html" data-ice="link">Getting Started</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/installation.html"><a href="manual/installation.html#set-up-artistoo-in-3-easy-steps" data-ice="link">Set up Artistoo in 3 easy steps</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#step-1--download-the-repository-" data-ice="link">Step 1: download the repository.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#step-2--install-node-dependencies-" data-ice="link">Step 2: install node dependencies.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#step-3--link-the-build-in-your-code-" data-ice="link">Step 3: link the build in your code.</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/installation.html"><a href="manual/installation.html#additional-notes" data-ice="link">Additional notes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/quickstart.html"><a href="manual/quickstart.html" data-ice="link">Your First Simulation</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/quickstart.html"><a href="manual/quickstart.html#set-up-a-simulation-in-the-web-browser" data-ice="link">Set up a simulation in the web browser</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#an-html-template-page" data-ice="link">An HTML template page</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/quickstart.html"><a href="manual/quickstart.html#set-up-a-simulation-in-nodejs" data-ice="link">Set up a simulation in nodejs</a></li>
<li data-ice="manualNav" class="indent-h2" data-link="manual/quickstart.html"><a href="manual/quickstart.html#writing-your-simulation" data-ice="link">Writing your simulation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#step-1---configure-the-cpm--amp--simulation" data-ice="link">Step 1 : Configure the CPM &amp; Simulation</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#step-2--create-a-simulation-object" data-ice="link">Step 2: Create a simulation object</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-nodejs" data-ice="link">In nodejs</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-html" data-ice="link">In HTML</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/quickstart.html"><a href="manual/quickstart.html#step-3---tell-the-simulation-to-run" data-ice="link">Step 3 : Tell the simulation to run</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-nodejs" data-ice="link">In nodejs</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/quickstart.html"><a href="manual/quickstart.html#in-html" data-ice="link">In HTML</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html" data-ice="link">An HTML Template</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#an-html-template" data-ice="link">An HTML template</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-1---create-a-basic-html-page" data-ice="link">Step 1 : Create a basic HTML page</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-2---configure-the-header" data-ice="link">Step 2 : Configure the header</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-3---add-javascript" data-ice="link">Step 3 : Add JavaScript</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-4--write-the-body" data-ice="link">Step 4: Write the body</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/htmlTemplate.html"><a href="manual/htmlTemplate.html#step-5--optional---add-css" data-ice="link">Step 5 (optional): Add CSS</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html" data-ice="link">Configuring Simulations (1)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#configuring-the-cpm-itself" data-ice="link">Configuring the CPM itself</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#changing-cpm-parameters" data-ice="link">Changing CPM parameters</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#setting-a-random-seed" data-ice="link">Setting a random seed</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#configuring-the-grid" data-ice="link"> Configuring the grid</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#field-size" data-ice="link"> Field size </a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#grid-boundaries" data-ice="link"> Grid boundaries</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#configuring-the-simulation-object" data-ice="link">Configuring the Simulation object </a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#controlling-the-simulation" data-ice="link">Controlling the simulation</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#controlling-the-visualization" data-ice="link">Controlling the visualization</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/simulationConfig.html"><a href="manual/simulationConfig.html#controlling-outputs" data-ice="link">Controlling outputs</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html" data-ice="link">Adding CPM Constraints</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#constraint-types" data-ice="link">Soft versus hard constraints</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#soft-constraints" data-ice="link">Soft constraints</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#hard-constraints" data-ice="link">Hard constraints</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#adding-constraints" data-ice="link">Adding a constraint to a model</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#method-1-conf" data-ice="link">Method 1: via the conf object</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#method-2-add" data-ice="link">Method 2: via the add() method</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#accessing-constraints" data-ice="link">Accessing a constraint in your model</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/addConstraints.html"><a href="manual/addConstraints.html#implementation-details" data-ice="link">Implementation details</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/simulationConfig2.html"><a href="manual/simulationConfig2.html" data-ice="link">Configuring Simulations (2)</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig2.html"><a href="manual/simulationConfig2.html#overwriting-methods" data-ice="link">Overwriting methods</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig2.html"><a href="manual/simulationConfig2.html#custom-initialization" data-ice="link">Custom initialization</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig2.html"><a href="manual/simulationConfig2.html#custom-drawing" data-ice="link">Custom visualization</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig2.html"><a href="manual/simulationConfig2.html#custom-stat-logging" data-ice="link">Custom logging</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/simulationConfig2.html"><a href="manual/simulationConfig2.html#other-processes" data-ice="link">Adding biological processes</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/sharingSimulations.html"><a href="manual/sharingSimulations.html" data-ice="link">Sharing Your Simulations</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/sharingSimulations.html"><a href="manual/sharingSimulations.html#step-1-create-directory" data-ice="link">Step 1: Create a self-contained directory</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/sharingSimulations.html"><a href="manual/sharingSimulations.html#step-2-adjust-paths" data-ice="link">Step 2: Adjust relative paths</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/sharingSimulations.html"><a href="manual/sharingSimulations.html#step-3-share" data-ice="link">Step 3: Share</a></li>
</ul>
  </div>
<div data-ice="manual">
    <ul class="manual-toc">
      
    <li data-ice="manualNav" class="indent-h1" data-link="manual/custommodules.html"><a href="manual/custommodules.html" data-ice="link">Custom Modules</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/custommodules.html"><a href="manual/custommodules.html#a-custom-statistic" data-ice="link">A custom statistic</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/custommodules.html"><a href="manual/custommodules.html#step-1-custom-stat-class" data-ice="link">Step 1: Create a custom extension of the Stat class</a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/custommodules.html"><a href="manual/custommodules.html#step-2-implement-a-compute-method" data-ice="link"> Step 2: Implement a compute() method </a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/custommodules.html"><a href="manual/custommodules.html#step-3-implement-a-computeforcell-method" data-ice="link"> Step 3: Implement a computeForCell() method </a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/custommodules.html"><a href="manual/custommodules.html#step-4-clean-up" data-ice="link">Step 4 (Optional): clean-up </a></li>
<li data-ice="manualNav" class="indent-h4" data-link="manual/custommodules.html"><a href="manual/custommodules.html#step-5-use-statistic" data-ice="link">Step 5: Use statistic</a></li>
<li data-ice="manualNav" class="indent-h3" data-link="manual/custommodules.html"><a href="manual/custommodules.html#a-custom-constraint" data-ice="link">A custom constraint</a></li>
</ul>
  </div>
</div>
</nav>

<div class="content" data-ice="content" id="mainContent">
<div class="github-markdown">
  <div class="manual-user-index" data-ice="manualUserIndex"><h1 id="artistoo--artificial-tissue-toolbox-">Artistoo (Artificial Tissue Toolbox)</h1>
<p>This manual is under construction. It currently contains some basic instructions
on how to get started, but stay tuned for the most recent version! In
the meantime, see the <a href="./examples.html">examples</a>
(with provided <a href="https://github.com/ingewortel/artistoo/tree/master/examples">code</a>)
and the full <a href="./identifiers.html">method documentation</a>
to get an idea of what you can do with Artistoo.
</p>
</div>



  

  <div class="manual-cards">
    
  <div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Getting Started</h1><h2>Set up Artistoo in 3 easy steps</h2><h3>Step 1: download the repository.</h3>
<p><strong>Via the Github website</strong>
</p><p>Visit the <a href="https://github.com/ingewortel/artistoo">Github repository</a> and click on the
green &quot;clone or download&quot; button, then select &quot;Download ZIP&quot;:
</p>
<p><img class="screen-shot" src="./manual/asset/github-repo2.png" width="80%">
</p><p>Save the zipped folder somewhere on your computer and unzip.</p><p><strong>Via the command line</strong></p><p>Alternatively, in the console, go to the folder where you want to save Artistoo,
and clone the repository:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">cd folder/to/save-into/
git clone https://github.com/ingewortel/artistoo.git</code>
</code></pre><h3>Step 2: install node dependencies.</h3>
<p>Most users will run Artistoo in browser simulations only and will not need to
extend the software with custom modules. If that&apos;s you, you can skip this step.
But if you plan to use Artistoo from the command line using node, or if you plan
to write your own modules (such as hamiltonian terms), you will need to install
some node dependencies.
</p>
<p>To do this, go to the <code>artistoo/</code> folder from the command line and install the
required packages automatically using <code>npm</code>:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">cd folder/containing/artistoo
npm install</code>
</code></pre>
<p>If you do not have <code>nodejs</code> and its package manager <code>npm</code>, see
<a href="https://nodejs.org/en/download/">this page</a> to install them first.
</p><h3>Step 3: link the build in your code.</h3>
<p>You can now use Artistoo! See this <a href="./manual/quickstart.html">tutorial</a> to build your first
simulation, or start from one of the simulations in the <code>artistoo/examples/</code>
folder. In these examples, you will see that the package can be loaded as
follows:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;script src=&quot;path/to/artistoo/build/artistoo.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>for html, and
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let CPM = require(&quot;path/to/artistoo/build/artistoo-cjs.js&quot;)</code>
</code></pre>
<p>for node scripts.
</p><p>When you include these lines in your own scripts, just make sure they contain
the correct path from your simulation file to the <code>artistoo/build/</code> folder.
</p><h3>Additional notes</h3>
<p>If you wish to build simulations in a different directory than the <code>artistoo</code>
folder, it may be convenient to create a symbolic link to the <code>build</code> folder
there:
</p><pre><code><code class="source-code prettyprint">cd path/to/my/simulations
ln -s path/to/artistoo/build build</code>
</code></pre>
<p>You can then access the code using:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;script src=&quot;path/to/my/simulations/build/artistoo.js&quot;&gt;&lt;/script&gt;</code>
</code></pre>
<p>or
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let CPM = require(&quot;path/to/my/simulations/build/artistoo-cjs.js&quot;)</code>
</code></pre>
<p>Finally, if you want to run Artistoo simulations with nodejs from this folder,
you will need to create a link to the installed <code>node_modules</code> from step 2:
</p><pre><code class="lang-console"><code class="source-code prettyprint">cd path/to/my/simulations
ln -s path/to/artistoo/node_modules node_modules</code>
</code></pre></div>
        <a data-ice="link" href="manual/installation.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Your First Simulation</h1>
<p>This tutorial will show you how to build a simple simulation in the web browser
or in a nodejs script. Choose either
<a href="#set-up-a-simulation-in-the-web-browser">Set up a simulation in the web browser</a>
or <a href="#set-up-a-simulation-in-nodejs">Set up a simulation in nodejs</a> to get the
required template code, and then see
<a href="#writing-your-simulation">Writing your simulation</a> to start using Artistoo in the
environment of your choice.
</p>
<p>The simulation we will build is a simple CPM cell:
your favourite web browser (as long as that favourite web browser is not
Internet Explorer). The advantage of this method is that it allows you to
visualize the simulation immediately, and that you can easily explore the
effect of changing parameters in this manner. However, if you wish to run a
simulation and store output to your computer, a simulation using nodejs may be
more appropriate &#x2013; see <a href="#set-up-a-simulation-in-nodejs">Set up a simulation in nodejs</a>
for details.
</p><h3>An HTML template page</h3>
<p>Unfortunately, writing an HTML page requires quite some boilerplate code. You
can mostly just copy-paste this for every simulation you build. For now,
we will just copy-paste the following template so you can continue with
<a href="#writing-your-simulation">building your simulation</a>. If you are unfamiliar with
HTML, you may want to check out <a href="./manual/htmlTemplate.html">this tutorial</a> later --
it will guide you through the template 
step by step so you know which parts you may have to adapt. 
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;!-- Page setup and title --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;
charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt; 
body{
    font-family: &quot;HelveticaNeue-Light&quot;, sans-serif; padding : 15px;
}
&lt;/style&gt;

&lt;!-- Sourcing the cpm build --&gt;
&lt;script src=&quot;../../build/artistoo.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;

            // Simulation code here.


&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;initialize()&quot;&gt;
&lt;h1&gt;Your Page Title&lt;/h1&gt;
&lt;p&gt;
Description of your page.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</code></pre>
<p>Copy the above code into a file called <code>MyFirstSimulation.html</code>, which you can
save in the <code>artistoo/examples/html/</code> folder for now. 
</p><blockquote>

<p>! <em>Important</em>: If you wish to save the file elsewhere, please read 
<a href="./manual/installation.html#additional-notes">these instructions</a> 
first, and ensure that you include the correct path to the cpm build in
the part <code>&lt;script src=&quot;../../build/artistoo.js&quot;&gt;&lt;/script&gt;</code>.
</p>
</blockquote>
<p>You can now proceed with
 <a href="#writing-your-simulation">adding your simulation</a> to this file.
</p><h2>Set up a simulation in nodejs</h2>
<p>Another way to use Artistoo &#x2013; besides using HTML &#x2013; is to use nodejs from the 
console. This method of running Artistoo allows you to print statistics to the 
console and store them in external files, as well as to save images of the 
simulation to create a movie later. To set up a more interactive version 
of your simulation with a live animation, an HTML version may be more 
appropriate &#x2013; see 
<a href="#set-up-a-simulation-in-the-web-browser">Set up a simulation in the web browser</a>
</p>
<p>In contrast to a browser simulation, a node simulation requires almost no 
boilerplate code. 
</p>
<p>To set up your first node simulation, just create a file <code>MyFirstSimulation.js</code>
in the folder <code>artistoo/examples/node/</code> 
(or see <a href="./manual/installation.html#additional-notes">these instructions</a> to create it 
elsewhere). Then add the following line of code to the (still empty) script to
source the package:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">/* Source the CPM module (cpm-cjs version because this is a node script).*/
let CPM = require(&quot;../../build/artistoo-cjs.js&quot;)</code>
</code></pre>
<p>Make sure that the path supplied to <code>require()</code> is the correct path from the
location of <code>MyFirstSimulation.js</code> to <code>artistoo/build/artistoo-cjs.js</code>.
</p>
<p>You can now proceed with <a href="#writing-your-simulation">adding your simulation</a>.
</p><h2>Writing your simulation</h2><p>We are now ready to add some simulation code. The following code goes either
in between the <code>&lt;script&gt;&lt;/script&gt;</code> tags of your HTML page (see the comment
<code>// Simulation code here</code>), or at the bottom of your node script.
</p>
<p>The easiest way to build a simulation in Artistoo is to use the 
<a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a>.
This class provides some default methods for running the simulation and 
producing outputs, so we won&apos;t have to worry about this yet. 
</p><h3>Step 1 : Configure the CPM &amp; Simulation</h3>
<p>The first thing we need to do is supply a <code>config</code> object with all the required
parameters and settings for the simulation. A configuration object for a simulation 
should look something like this:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {

    ndim : 2,
    field_size : [50,50],
    conf : {

    },
    simsettings : {

    }
}</code>
</code></pre>
<p>Here, <code>ndim</code> is the number of dimensions of the grid, <code>field_size</code> is the 
number of pixels in each dimension (in this case: 50 x 50 pixels), <code>conf</code> is 
the configuration object parsed to the 
<a href="./manual/../class/src/models/CPM.js~CPM.html">CPM class</a>, and <code>simsettings</code>
contains configuration options used directly by the simulation class.
</p>
<p>First, we configure the CPM by setting values in the <code>conf</code> object:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">conf : {
        T : 20,                        // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],            // VolumeConstraint importance per cellkind
        V : [0,500]                    // Target volume of each cellkind

    }</code>
</code></pre>
<p>The <code>T</code> parameter is the CPM temperature, which determines how strongly the 
model &quot;listens&quot; to the energy constraints given in the CPM. We then add 
an <a href="./manual/../class/src/hamiltonian/Adhesion.js~Adhesion.html">adhesion</a> and 
<a href="./manual/../class/src/hamiltonian/VolumeConstraint.js~VolumeConstraint.html">volume constraint</a> 
by supplying their parameters. In this case, we will have only one type of cell
and the background, so parameters are arrays of length 2 (or a 2 by 2 matrix 
for the adhesion parameters).
</p>
<p>Finally, we need to supply some settings for the simulation class itself in
<code>simsettings</code>:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">simsettings : {
    NRCELLS : [1],
    RUNTIME : 500,
    CANVASCOLOR : &quot;eaecef&quot;,
    zoom : 4
}</code>
</code></pre>
<p>This ensures that one cell is seeded on the grid before the simulation, the
simulation runs for 500 MCS (in node; in the browser it will just keep running),
the background of the grid is colored gray, and the grid is drawn at 4x zoom.
</p>
<p>The full <code>config</code> object becomes:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {

    // Grid settings
    ndim : 2,
    field_size : [100,100],

    // CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },

    // Simulation setup and configuration
    simsettings : {
        // Cells on the grid
        NRCELLS : [1],                    // Number of cells to seed for all
                                        // non-background cellkinds.

        RUNTIME : 500,                  // Only used in node

        CANVASCOLOR : &quot;eaecef&quot;,
        zoom : 4                        // zoom in on canvas with this factor.
    }
}</code>
</code></pre><h3>Step 2: Create a simulation object</h3>
<p>Once we have the configuration object, we can use it to construct a simulation.
</p><h4>In nodejs</h4><p>In nodejs, simply construct the simulation as follows:</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let sim = new CPM.Simulation( config )</code>
</code></pre><h4>In HTML</h4>
<p>If you are writing an HTML page, you have to define an <code>initialize()</code> function -
as this is the function that will be run when the page is loaded (see 
<a href="./manual/htmlTemplate.html#step-4-write-the-body">this section</a>):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let sim
function initialize(){
    sim = new CPM.Simulation( config )
}</code>
</code></pre><h3>Step 3 : Tell the simulation to run</h3>
<p>We are now almost ready; the only thing still missing is a command in the script
that tells the simulation to start running. This works slightly differently in
the browser- and nodejs versions.
</p><h4>In nodejs</h4>
<p>In nodejs, getting the simulation to run is easy: just call the <code>run()</code> method
of the simulation class after creating the simulation object. We get:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    ...
}
let sim = new CPM.Simulation( config )
sim.run()</code>
</code></pre>
<p>You are now ready to run your simulation. From your console, run the script with
node:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">node path/to/MyFirstSimulation.js</code>
</code></pre><h4>In HTML</h4>
<p>In HTML, we create a function that runs a single step, and then make sure that
this function is called from the <code>initialize()</code> function:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    ...
}
let sim
function initialize(){
    sim = new CPM.Simulation( config )
    step()
}
function step(){
    sim.step()
    requestAnimationFrame( step )
}</code>
</code></pre>
<p>To see your simulation, open your file MyFirstSimulation.html in the web 
browser (any except Internet Explorer; but we recommend Chrome because it is fast).
</p></div>
        <a data-ice="link" href="manual/quickstart.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>An HTML Template</h1>
<p>This tutorial will take you through the HTML simulation template 
step by step so you know which parts you may have to adapt when 
you are building your own simulations.
</p><h3>An HTML template</h3>
<p>We will build the following template:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;!-- Page setup and title --&gt;
&lt;!DOCTYPE html&gt;
&lt;html lang=&quot;en&quot;&gt;
&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;
charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;style type=&quot;text/css&quot;&gt; 
body{
    font-family: &quot;HelveticaNeue-Light&quot;, sans-serif; padding : 15px;
}
&lt;/style&gt;

&lt;!-- Sourcing the cpm build --&gt;
&lt;script src=&quot;../../build/artistoo.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;

            // Simulation code here.


&lt;/script&gt;
&lt;/head&gt;
&lt;body onload=&quot;initialize()&quot;&gt;
&lt;h1&gt;Your Page Title&lt;/h1&gt;
&lt;p&gt;
Description of your page.
&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;</code>
</code></pre>
<p>We will now go through this step by step.
</p><h3>Step 1 : Create a basic HTML page</h3><p>A very simple HTML page looks like this:</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt; &lt;/head&gt;
&lt;body&gt; &lt;/body&gt;
&lt;/html&gt;</code>
</code></pre>
<p>The <code>&lt;html&gt;</code> tag shows where the page starts, and <code>&lt;/html&gt;</code> shows where it ends.
The page consists of a <em>header</em>, which starts at <code>&lt;head&gt;</code> and ends at <code>&lt;/head&gt;</code>,
and a <em>body</em>, starting at <code>&lt;body&gt;</code> and ending at <code>&lt;/body&gt;</code>. (In general,
anything you place in your HTML file starts with <code>&lt;something&gt;</code> and ends with
<code>&lt;/something&gt;</code>).
</p><h3>Step 2 : Configure the header</h3>
<p>The header of the HTML page is the place that contains some meta-information
about that page, and will also contain the simulation code.
</p>
<p>First, we will expand the header code above (between the <code>&lt;head&gt;&lt;/head&gt;</code> tags):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;/head&gt;</code>
</code></pre>
<p>The additional code in the first line just includes some document settings into 
the header that you will rarely need to change. The only thing you may want to 
change is the second line, where you set the title that will be displayed
in the open tab in your web browser when you open the page.
</p><h3>Step 3 : Add JavaScript</h3>
<p>We will now add some JavaScript code to the header part of the page (again,
between the <code>&lt;head&gt;&lt;/head&gt;</code> tags):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;
&lt;script src=&quot;path/to/artistoo/build/artistoo.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;
// Simulation code will go here:

&lt;/script&gt;
&lt;/head&gt;</code>
</code></pre>
<p>The first script just loads the Artistoo package for HTML, which is stored in
<code>artistoo/build/artistoo.js</code>. Please ensure that the path supplied here is the correct
path from the folder where you stored <code>MyFirstSimulation.html</code> to the file
<code>artistoo/build/artistoo.js</code>. If you have stored your simulation in <code>artistoo/examples/html</code>,
you can use the path <code>../../build/artistoo.js</code>
</p>
<p>The second script is where your actual simulation code
will go when you are <a href="./manual/quickstart.html#writing-your-simulation">Writing your simulation</a>.
For now, we&apos;ll leave it empty.
</p><h3>Step 4: Write the body</h3>
<p>Finally, we make some changes to the body of the page (between the <code>&lt;body&gt;&lt;/body&gt;</code> tags):
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">&lt;body onload=&quot;initialize()&quot;&gt;
&lt;h1&gt;Your Page Title&lt;/h1&gt;
&lt;p&gt;
Description of your page.
&lt;/p&gt;
&lt;/body&gt;</code>
</code></pre>
<p>In the first line, we tell the HTML page to run the JavaScript function 
<code>intitialize()</code>, which we will define later in 
<a href="./manual/quickstart.html#writing-your-simulation">Writing your simulation</a> (between the 
<code>&lt;script&gt;&lt;/script&gt;</code> tags of the page header we just set up).
</p>
<p>The rest of the code just adds a title and a description to the web page.
The simulation will then be placed below (as in the example shown
at the top of this page).
</p><h3>Step 5 (optional): Add CSS</h3>
<p>The code we have now added is sufficient to make the page work once we have
<a href="./manual/quickstart.html#writing-your-simulation">added a simulation</a>, but to make it look better we
may want to add some CSS styling code to the header of the page. The header now
becomes:
</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">
&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;
&lt;title&gt;PageTitle&lt;/title&gt;

&lt;style type=&quot;text/css&quot;&gt; 
body{
font-family: &quot;HelveticaNeue-Light&quot;, sans-serif; padding : 15px;
}
&lt;/style&gt;

&lt;script src=&quot;path/to/artistoo/build/artistoo.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
&quot;use strict&quot;
// Simulation code will go here:

&lt;/script&gt;
&lt;/head&gt;</code>
</code></pre>
<p>To see the final result, have a look again at the complete
 <a href="#an-html-template">template</a>. You can now proceed with
 <a href="./manual/quickstart.html#writing-your-simulation">adding your simulation</a> to this file.
</p></div>
        <a data-ice="link" href="manual/htmlTemplate.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Configuring Simulations (1)</h1>
<p>
</p><p></p><p>
Once you have written a <a href="./manual/./quickstart.html">fist simulation</a>, you can 
adapt it by modifying parameters, 
or you can increase the number of cells in your simulation and examine 
interactions between different cell types.
</p>
<p>
</p><p></p><p>The <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a>
allows you to make many of those changes by simply modifying the its
<a href="./manual/./quickstart.html#step-1---configure-the-cpm--amp--simulation">configuration object</a>, 
which will be the topic of this tutorial. 
The next tutorial will show you how you can make even more advanced simulations 
by writing custom functions - but for now we will focus on changes you can make
through configuration only.
</p>
<p>
</p><p></p><p>We will start from this very simple simulation from the 
<a href="./manual/./quickstart.html">previous tutorial</a>:

<div>
<iframe src="./manual/asset/SingleCell.html" width="350px" height="400px"> </iframe>
</div>


</p>
<p>
This tutorial assumes you have completed the previous tutorial, and we will 
examine the <code>config</code> object of the simulation you generated there in more detail:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {

    // Grid settings
    field_size : [100,100],

    // CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },

    // Simulation setup and configuration
    simsettings : {
        // Cells on the grid
        NRCELLS : [1],                    // Number of cells to seed for all
                                        // non-background cellkinds.

        RUNTIME : 500,                  // Only used in node

        CANVASCOLOR : &quot;eaecef&quot;,
        zoom : 4                        // zoom in on canvas with this factor.
    }
}</code></code></pre>


</p>
<p>
</p><p>We will now see how changes to this object can alter the simulation.</p><p></p><p></p><h3>Configuring the CPM itself</h3><p></p><p></p><p>First, let&apos;s see how we can control the <a href="./manual/../class/src/models/CPM.js~CPM.html">
CPM model class</a> itself. For this lesson, we recommend you start from the HTML version 
of the simulation in the <a href="./manual/./quickstart.html">previous tutorial</a>.
This HTML version will allow you to
see the effect of your changes more quickly than running a node script would.
</p>
<p>
</p><p></p><h4>Changing CPM parameters</h4><p></p><p></p><p>As we&apos;ve seen before, the <code>config</code> object has three parts: the 
<code>field_size</code>, the <code>conf</code>, and the <code>simsettings</code>. 
We will now look at the <code>conf</code> part, which controls the CPM model itself.
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">// CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },</code></code></pre>


</p>
<p>
</p><p>The CPM shown here has only two constraints: the 
<a href="./manual/../class/src/hamiltonian/Adhesion.js~Adhesion.html">Adhesion</a> and
<a href="./manual/../class/src/hamiltonian/VolumeConstraint.js~VolumeConstraint.html">Volume</a>
constraints. The <code>T</code> parameter belongs to the CPM itself and controls to
what extent the model &quot;listens&quot; to the energy rules it gets. The higher T, the more likely
the model is to misbehave. But if T is too low, the cell might get stuck in a state it
can&apos;t get out of.

</p>
<p>
</p><p><b>Exercise</b> : </p><p><i>Try some different values for T here, and see what happens with your simulation.</i></p><p></p><p>The other parameters here belong to the constraints. The <code>J</code> values form
a matrix controlling the adhesion between cell and background. The $J_{00}$ value, which
is here 0, is never used (the adhesion constraint only counts adhesion between pixels
belonging to different cells, and since there is only one background &quot;cell&quot;, there can
be no background-background adhesion). The $J_{01}$ and $J_{10}$ values (here 20) are
the adhesion between cell and background, and are important for this simulation. 
The $J_{11}$ would be the adhesion between two different cells and is also not relevant
yet, since there is only one cell.
</p>
<p>
</p><p></p><p>The <code>V</code> and <code>LAMBDA_V</code> parameters control the volume constraint,
see its <a href="./manual/../class/src/hamiltonian/VolumeConstraint.js~VolumeConstraint.html">documentation</a>. 
</p>
<p>
</p><p><b>Exercises</b> : </p><p><ol>
<li><i>Change the values in <code>J</code>, and try to make the cell fall apart. Do you
understand why this happens?</i></li>
<li><i>How would you make the cell twice as big? Try it.<i></i></i></li>
</ol>


</p>
<p>
</p><p>Finally, note that we can also add more different constraints to the model via the
<code>conf</code> object. We&apos;ll do that in a later tutorial.
</p>
<p>
</p><p></p><h4>Setting a random seed</h4><p></p><p></p><p>If you look at the simulation on the top of this page and then refresh a few times, 
you should see that every simulation &quot;run&quot; goes a little differently. This happens because
the CPM is stochastic. If you don&apos;t want this, because you want someone else to be able
to reproduce exactly your results, you can try setting a random <code>seed</code>:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">// CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature
        seed : 1,

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },</code></code></pre>



</p>
<p><b>Exercise</b> :
</p><p><i>Set a random seed in your simulation&apos;s HTML file. Refresh the page a few times
and look what happens. What is different now?</i>
</p>
<p>
</p><h3> Configuring the grid</h3><p></p><p></p><h4> Field size </h4><p></p><p></p><p>Open your file <code>MyFirstSimulation.html</code> from the previous tutorial in the web
browser. You should see a black cell floating inside a square gray area, which
is the field or &quot;grid&quot; the simulation runs in.
</p>
<p>
</p><p></p><p> The size of this grid is controlled by <code>field_size</code> in the <code>config</code> 
object. The entry 
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">// Grid settings
field_size : [100,100],</code></code></pre>



</p>
<p>
</p><p>
ensures that the simulation is performed on a 100 x 100 pixel (2D) grid. We can change 
the size of this grid by changing the numbers <code>x</code> and <code>y</code> between
the square brackets: <code>[x,y]</code>, where <code>x</code> controls the grid&apos;s width 
and <code>y</code> controls its height. For example, changing this setting to:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">    // Grid settings
    field_size : [150,100], </code></code></pre>



</p>
<p>
</p><p>makes the grid slightly broader, but equally high as before.</p><p></p><p><b>Exercise</b> : </p><p><i>How would you make a grid with a width of 100 pixels and a
height of 200 pixels? Open your file</i> <code>MyFirstSimulation.html</code> <i>in your 
favourite text editor, change the</i> <code>field_size</code> <i>in the appropriate manner, 
and save the file. Now open</i> <code>MyFirstSimulation.html</code> <i>in your web browser 
(or just refresh the page if you had already done so). Did it work?</i>
</p>
<p>
</p><h4> Grid boundaries</h4><p></p><p></p><p>Have a look at the following simulation:</p><p></p><p><div>
<iframe src="./manual/asset/ActSmall.html" width="350px" height="300px"> </iframe>
</div>


</p>
<p>
</p><p> When the cell leaves the grid on the right, we see that it re-enters on the left.
We call this a grid with <i>periodic boundaries</i>. Because grid boundaries are linked,
the cell feels as though it is roaming an infinite space.
</p>
<p>
</p><p></p><p>In the <code>CPM</code> object, the grid boundary conditions can be set through the
<code>torus</code> property in the configuration object like this:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">// CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature
        torus : [true,true],

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },</code></code></pre>


</p>
<p>
</p><p>When <code>torus=true</code>, this means that the grid boundaries are linked as in the
example above (this is also the default when we don&apos;t supply the <code>torus</code>
property in the configuration settings). If we don&apos;t want linked boundaries, we can
change this value to false:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">// CPM parameters and configuration
    conf : {
        T : 20,                                // CPM temperature
        torus : [false,false],

        // Adhesion parameters:
        J: [[0,20], [20,100]] ,

        // VolumeConstraint parameters
        LAMBDA_V : [0,50],                // VolumeConstraint importance per cellkind
        V : [0,500]                        // Target volume of each cellkind
    },</code></code></pre>


</p>
<p>
</p><p>However, what we get is not quite what we intended: </p><p></p><p><div>
<iframe src="./manual/asset/ActSmall2.html" width="350px" height="300px"> </iframe>
</div>


</p>
<p>
</p><p>The problem here is that we can&apos;t just say that there are boundaries without telling
the CPM how to deal with those boundaries. A pixel at the border of the grid will have 
fewer neighboring pixels to contribute to its 
<a href="./manual/../class/src/hamiltonian/Adhesion.js~Adhesion.html">adhesion</a> or 
<a href="./manual/../class/src/hamiltonian/PerimeterConstraint.js~PerimeterConstraint.html">surface</a>
energy, which will give artefacts. In reality, any physical boundary a cell might
encounter <i>would</i> contribute to adhesion energy.
</p>
<p>
</p><p></p><p>To solve such problems, it is possible to create a layer of boundary pixels at the
edges of the grid, to which the adhesion can be explicitly defined. See
<a href="./manual/../examples/NoTorusDemo.html">this example</a> for details and implementation (once you see the simulation,
right click on the page (outside of the simulation grid) and select &quot;view page source&quot; 
to see code).
</p>
<p>
</p><p></p><h3>Configuring the Simulation object </h3><p></p><p></p><p>The <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation object</a> 
automatically takes care of many aspects of the
simulation, such as seeding cells on the grid, running the simulation for a number of 
steps, drawing the output images and computing output statistics. We&apos;ll discuss how to
tune some of these aspects here.
</p>
<p>
</p><p></p><p>Have a look at the documentation for the <code>constructor</code> of the simulation
class <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html#instance-constructor-constructor">here</a>. 
All the options listed under <code>simsettings</code> here are options to configure the 
simulation, which we will discuss here.
</p>
<p>
</p><p></p><h4>Controlling the simulation</h4><p></p><p></p><p>Using the option <code>NRCELLS</code>, we can specify how many cells of each 
<a href="./manual/../typedef/index.html#static-typedef-CellKind">CellKind</a> we want to seed
on the grid at the beginning of the simulation. Note that this needs to be an array with
one element for each non-background cellkind on the grid. This means this array is one
element shorter than most typical CPM parameters (e.g. <code>LAMBDA_V</code>) which are
specified for each cellkind <i>including</i> background. If the lengths of these 
different arrays are not consistent with each other, the CPM will get confused about
how many cellkinds you want on the grid. It will crash.
</p>
<p>
</p><p></p><p>By default, the simulation class seeds them in random positions. We&apos;ll discuss how 
to seed cells in more customized locations in a later tutorial. But for now, try 
modifying the <code>NRCELLS</code> property of your simulation and see what happens.
</p>
<p>
</p><p></p><p>The <code>RUNTIME</code> property determines for how many Monte Carlo Steps (MCS) the
simulation will run. This property is actually only used by node simulations. 
You can use the <code>RUNTIME_BROWSER</code> property in the browser, but then you must
use that in your <code>step()</code> function like this: 
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function step(){
    sim.step()
    meter.tick()
    if( sim.conf[&quot;RUNTIME_BROWSER&quot;] == &quot;Inf&quot; | sim.time+1 &lt; sim.conf[&quot;RUNTIME_BROWSER&quot;] ){
        requestAnimationFrame( step )
    }
}</code></code></pre>


</p>
<p>
</p><p>This way, the simulation will only keep running until <code>RUNTIME_BROWSER</code> is
reached. If we wouldn&apos;t do this, the browser simulation would just keep running infinitely
(or in practice, until your patience or your computer&apos;s battery runs out and you close 
the browser window).
</p>
<p>
</p><p></p><h4>Controlling the visualization</h4><p></p><p></p><p>The Simulation class contains a default method 
<a href="./manual/../file/src/simulation/Simulation.js.html#lineNumber210"><code>drawCanvas()</code></a>
that takes care of drawing the grid for you. You can control the way this function draws
the grid via the <code>simsettings</code> object as well, by setting: 
</p>
<p>
</p><p><ul>
    <li><code>CANVASCOLOR</code>, the color code to draw the background in. If left
    unspecified, this is white (<code>&quot;FFFFFF&quot;&quot;</code>).</li>
    <li><code>CELLCOLOR</code>, the color code to draw the cells in. If left
    unspecified, this is black (<code>&quot;000000&quot;&quot;</code>). If you do wish to specify it,
    you must provide an array with a color for each <a href="./manual/../typedef/index.html#static-typedef-CellKind">CellKind</a>
    just like we did for NRCELLS above. E.g. for one black and one red cell kind, that would
    be <code>[&quot;000000&quot;,&quot;FF0000&quot;]</code></li>
    <li><code>ACTCOLOR</code>, whether or not to draw the activity gradient if the cells
    have an <a href="./manual/../class/src/hamiltonian/ActivityConstraint.js~ActivityConstraint.html">
    ActivityConstraint</a>. If left unspecified, this is set to <code>false</code> for 
    each <a href="./manual/../typedef/index.html#static-typedef-CellKind">CellKind</a>. </li>
    <li><code>SHOWBORDERS</code>, whether or not to draw the borders of each cell as well
    as their area. This is <code>false</code> by default.</li>
    <li><code>BORDERCOL</code>, the color to draw the cell borders in, once more specified
    for each <a href="./manual/../typedef/index.html#static-typedef-CellKind">CellKind</a>. This
    is only used whenever <code>SHOWBORDERS</code> is set to <code>true</code>.</li>
    <li><code>zoom</code>the factor by which to enlarge the image (note that using a higher
    zoom factor may slow down your simulation, since it takes more time to draw the grid
    in a larger image. If a simulation is fast enough, this won&apos;t be an issue, but if
    you notice your simulations being too slow you might want to adjust this factor).</li>
</ul>


</p>
<p>
</p><p>For all the options involving color, this online <a href="https://www.google.com/search?q=color+picker">
color picker</a> may come in handy.
</p>
<p>
</p><p><b>Exercise</b> :</p><p><i>Given all the information we have covered so far, can you reproduce a simulation that 
looks roughly like the one below?</i>
</p>
<p><div>
<iframe src="./manual/asset/ColorEx.html" width="450px" height="450px"> </iframe>
</div>




</p>
<p>
</p><h4>Controlling outputs</h4><p></p><p></p><p>The simulation class helps you by generating outputs automatically. This happens inside
the function <a href="./manual/../file/src/simulation/Simulation.js.html#lineNumber328"><code>createOutputs()</code></a>, 
which does two things:
</p>
<p>
</p><p><ol>
    <li>Drawing things on the screen (browser version) or on an output PNG image (node version)</li>
    <li>Computing and logging statistics to the console (both versions)</li>
</ol>


</p>
<p>
</p><p>In node, you can control the following aspects of the PNG images that are written:</p><p></p><p><ul>
    <li><code>SAVEIMG</code>, are any images saved at all? Defaults to <code>false</code>;</li>
    <li><code>IMGFRAMERATE</code>, how often should an image be saved? Defaults to 
        <code>1</code> (save an image every simulation step), but you might set it to e.g.
        <code>10</code> to save an image only once every 10 steps. This may significantly
        speed up your simulations since drawing images can be a speed bottleneck. Very often,
        drawing every step is not necessary to get a smooth movie in the end;</li>
    <li><code>SAVEPATH</code>, in which folder should images be stored? You have to make 
        sure this folder exists, or you will get an error. Although this option is documented
        as &quot;optional&quot;, this is only true because you don&apos;t have to give it when 
        <code>SAVEIMG=false</code>. If you set <code>SAVEIMG=true</code>, you must provide this
        option.</li>
    <li><code>EXPNAME</code>, a name used to generate the name of the output images. These
        will be stored as <code>[SAVEPATH]/[EXPNAME]-t[STEP].png</code>. Defaults to
        <code>&quot;mysim&quot;</code>.</li>
</ul>


</p>
<p>
</p><p>Note that the options above only apply to node, since the browser version does not support
writing PNG images. If you want to make a movie from the browser version, just record your
screen. If you wish to change the <code>IMGFRAMERATE</code> of your browser simulation,
you can adjust your <code>step()</code> function (see also <a href="./manual/./quickstart.html">
this tutorial</a>) to something like this:

<pre><code class="lang-$xslt"><code class="source-code prettyprint">function step(){
    // Run IMGFRAMERATE simulation steps before rendering
    for( let s = 0; s &lt; config.simsettings.IMGFRAMERATE; s++ ){
        sim.step()
    }
    requestAnimationFrame( step )
}</code></code></pre>


</p>
<p>Note that <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html#instance-method-step">
<code>sim.step()</code></a> will still call 
<a href="./manual/../class/src/simulation/Simulation.js~Simulation.html#instance-method-drawCanvas">
<code>drawCanvas()</code></a> every 
step, but the grid will only be <i>rendered</i> once every <code>IMGFRAMERATE</code>
steps. Since rendering is often the bottleneck, this will still speed up your simulation
most of the times.
</p>
<p>
</p><p></p><p>The <a href="./manual/../file/src/simulation/Simulation.js.html#lineNumber328"><code>createOutputs()</code></a>
also takes care of logging statistics to the console. By default, it logs the simulation
step, the <a href="./manual/../typedef/index.html#static-typedef-CellId">cellID</a>, the
<a href="./manual/../typedef/index.html#static-typedef-CellKind">CellKind</a>, and the centroid
of every cell on the grid. To adjust this, you can overwrite this method, which we will
discuss in a later tutorial.
</p>
<p>
</p><p></p><p>Two settings in the <code>simsettings</code> object control the logging of statistics:</p><p></p><p><ul>
    <li><code>LOGSTATS</code>, specifying for browser and node separately whether statistics
    should be logged to the console. Defaults to <code>{ browser: false, node: true }<code>;</code></code></li>
    <li><code>LOGRATE</code>, specifying how often statistics are computed and logged. Defaults to 
        <code>1</code> (log every simulation step), but you might set it to e.g.
        <code>10</code> to log only once every 10 steps.</li>
</ul>


</p></div>
        <a data-ice="link" href="manual/simulationConfig.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Adding CPM Constraints</h1>
<p>
</p><p></p><p>
One of the strengths of the CPM is that it can incorporate different processes of interest
as separate &quot;rules&quot; given to the model. These rules can be mixed and matched to get a
simulation of interest, making the CPM a very flexible framework. Artistoo implements
a diverse set of model rules, called <a href="./manual/../identifiers.html#hamiltonian">Constraints</a>.
This tutorial will walk you through how to use these constraints in your models.

</p>
<p>
</p><p></p><h3>Soft versus hard constraints</h3><p></p><p></p><p>In Artistoo, we distinguish two types of constraints: <a href="#hard-constraints">&quot;hard&quot;
</a> and <a href="#soft-constraints">&quot;soft&quot;</a> constraints.
</p>
<p>
</p><p></p><h4>Soft constraints</h4><p></p><p></p><p>&quot;Soft&quot; constraints are the classical CPM energy rules. They are the terms of the
model&apos;s Hamiltonian, or energy equation. When a copy attempt would break such a rule,
this becomes visible as an energetic penalty making that copy attempt <i>less likely</i>.
But a soft constraint is more a guideline than an actual rule; the model will <i>mostly</i>
adhere to it, but not always.
</p>
<p>
</p><p></p><p>For example, suppose we have a cell with a <a href="./manual/../class/src/hamiltonian/VolumeConstraint.js~VolumeConstraint.html">volume constraint</a>, and that
cell is already larger than its target volume. A copy attempt that would add another pixel
to that cell would be associated with a $&#x394;H_\text{vol} \gt 0$. However, that 
does <i>not</i> mean that this copy attempt will always fail to go through. First, it may
be that there are other constraints acting on the model for which this copy attempt <i>is</i>
favourable, compensating for the volume penalty such that the <i>global</i> $&#x394;H$
is still negative. Second, even if the global $&#x394;H$ is positive, a copy attempt may
still be accepted with a chance $e^{-&#x394;H T}$. Thus, soft constraints make some changes
more likely to happen than others, but they can balance each other out and are not always
listened to.
</p>
<p>
</p><p></p><p>Most CPM constraints are soft constraints. But sometimes, there are things we would 
like to <i>forbid</i> completely. For that, we can use a hard constraint.
</p>
<p>
</p><p></p><h4>Hard constraints</h4><p></p><p></p><p>Whereas soft constraints are more guidelines than rules, &quot;hard&quot; constraints are set
in stone. Before the $&#x394;H$ of a copy attempt is even computed, Artistoo checks whether
it violates one of the hard constraints. If it does, it won&apos;t go through - ever.
</p>
<p>
</p><p></p><p>Not many constraints are hard constraints, and in a typical CPM, you should be careful
using them. But examples are the <a href="./manual/../class/src/hamiltonian/HardVolumeRangeConstraint.js~HardVolumeRangeConstraint.html">
HardVolumeRangeConstraint</a>, the <a href="./manual/../class/src/hamiltonian/BarrierConstraint.js~BarrierConstraint.html">BarrierConstraint</a>, and the hard 
<a href="./manual/../class/src/hamiltonian/ConnectivityConstraint.js~ConnectivityConstraint.html">
ConnectivityConstraint</a>. See also this example of a &apos;particle&apos; following a random walk,
where we constrained the volume such that the cell can only be one or two pixels big:
</p>
<p>
</p><p><div>
<iframe src="./examples/RandomWalk.html" width="100%" height="600px"> </iframe>
</div>




</p>
<p>
</p><h3>Adding a constraint to a model</h3><p></p><p></p><p>There are two ways of adding a constraint to your model, which we will explain here.</p><p></p><p></p><h4>Method 1: via the conf object</h4><p></p><p></p><p> The first method is to add the relevant constraint parameters to the <code>conf</code>
object. This is the easiest method to add a constraint, but it only works for a few of the 
most used constraints (see <a href="./manual/../variable/index.html#static-variable-AutoAdderConfig">this page</a> for a list of the constraints for which this works). 
</p>
<p>
</p><p></p><p>For example: </p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let myCPM = new CPM.CPM(
    [ 200, 200 ],
    {
        T : 20,
        J : [[0,20],[20,0]],
        V : [0,500],
        LAMBDA_V: [ 0, 50]
    }

)</code></code></pre>


</p>
<p>
</p><p>will automatically create a CPM with an adhesion and a volume constraint inside it.
If we open the browser console from a page with an Artistoo simulation in it, e.g. 
<a href="./manual/../examples/ActModel.html">this one</a>, we can check this. Go to the page, 
right click anywhere on the page outside of the grid, select &quot;inspect&quot; and then &quot;console&quot;. 
Copy-paste the above code in the 
console and hit enter. If you now type: 
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">myCPM.soft_constraints</code></code></pre>


</p>
<p>
</p><p>and hit enter, you should see that there are two soft constraints in the model now:
an <code>Adhesion</code> and a <code>VolumeConstraint</code>.
</p>
<p>
</p><p></p><p>This works the same if we use the 
<a href="./manual/../class/src/simulation/Simulation.js~Simulation.html"><code>Simulation</code> class</a>,
because the <code>config.conf</code> is passed along internally to the CPM constructor.
So if we type:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let mySim = new CPM.Simulation(
    {
        field_size : [200,200],
        conf : {
            T : 20,
            J : [[0,20],[20,0]],
            V : [0,500],
            LAMBDA_V: [ 0, 50]<br>        },
        simsettings : {
            NRCELLS : [1]
        }
    }

)
mySim.C.soft_constraints</code></code></pre>


</p>
<p>
</p><p>we again see our two constraints appear.</p><p></p><p></p><h4>Method 2: via the add() method</h4><p></p><p></p><p>Note that, as mentioned, the first method does not work for all constraints. If we try to add
an <a href="./manual/../class/src/hamiltonian/AttractionPointConstraint.js~AttractionPointConstraint.html">
<code>AttractionPointConstraint</code></a> (another soft constraint) in this way:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let myCPM = new CPM.CPM(
    [ 200, 200 ],
    {
        T : 20,
        J : [[0,20],[20,0]],
        V : [0,500],
        LAMBDA_V: [ 0, 50],
        LAMBDA_ATTRACTIONPOINT : [0,100],
        ATTRACTIONPOINT: [[0,0],[100,100]]
    }

)</code></code></pre>



</p>
<p>
</p><p>then if we type:</p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">myCPM.soft_constraints</code></code></pre>


</p>
<p>
</p><p>we still only have our <code>Adhesion</code> and a <code>VolumeConstraint</code>.
The <code>AttractionPointConstraint</code>has not been added.
</p>
<p>
</p><p></p><p>To add this constraint, we must use the <a href="./manual/../class/src/models/CPM.js~CPM.html#instance-method-add">
<code>add()</code> method</a> of the CPM class. If we have already put the relevant parameters
in the <code>conf</code> object, this is easy:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">//add constraint
myCPM.add( new CPM.AttractionPointConstraint( myCPM.conf ) )
myCPM.soft_constraints</code></code></pre>


</p>
<p>
</p><p>you should now see an <code>AttractionPointConstraint</code> in the list of 
soft constraints. We&apos;ve given the entire <code>conf</code> object of the CPM to the
constraint&apos;s constructor, but it will just ignore the parameters that are not relevant
to this constraint. However, we can also just give it it&apos;s own <code>conf</code> object.
For example, we might add a second attraction point like this:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">//add another constraint
myCPM.add( new CPM.AttractionPointConstraint( {
        LAMBDA_ATTRACTIONPOINT : [0,100],
        ATTRACTIONPOINT: [[0,0],[150,150]]<br>} ) )
myCPM.soft_constraints</code></code></pre>


</p>
<p>
</p><p>You should now see two attraction point constraints in your list.</p><p></p><p></p><p>A word of warning: when you add a new constraint, the model will use it. It won&apos;t check
if another constraint of the same type was already present. For the example above, that&apos;s
perfectly fine because we might <i>want</i> to have two different points of attraction.
However, for other constraints such as the 
<a href="./manual/../class/src/hamiltonian/Adhesion.js~Adhesion.html"><code>Adhesion</code></a>,
this might not be what you want (basically, this will be the same as having only one
adhesion constraint where the parameters are twice as large. But someone checking your 
code may overlook your second adhesion constraint and think that the adhesion parameters 
are set lower than they actually are...).
</p>
<p>
</p><p></p><h3>Accessing a constraint in your model</h3><p></p><p></p><p>Once you&apos;ve put a constraint in your model, you may want to access it from outside.
The method <a href="./manual/../class/src/models/CPM.js~CPM.html#instance-method-getConstraint"><code>getConstraint()</code></a> allows you to do that. For
example:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">//get volumeconstraint
myCPM.getConstraint( &quot;VolumeConstraint&quot; )</code></code></pre>


</p>
<p>
</p><p>will return the <code>VolumeConstraint</code> that is currently in your model.</p><p></p><p></p><p>If there are multiple constraints of the same name in your model, this method
automatically gives you the first one:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">//get the first attraction point constraint
myCPM.getConstraint( &quot;AttractionPointConstraint&quot; )</code></code></pre>


</p>
<p>
</p><p>This yields the first attraction point we added (from the browser console, you can 
click the little triangle on the left to see more about the object. If you look at its
<code>conf</code> object, you see that this is the settings we gave to our first 
attraction point constraint).
</p>
<p>
</p><p></p><p>If we want to access the second attraction point, we can type:</p><pre><code class="lang-$xslt"><code class="source-code prettyprint">//get the second attraction point constraint
myCPM.getConstraint( &quot;AttractionPointConstraint&quot;, 1 )</code></code></pre>
<p><i>(Note here that JavaScript uses zero-based indexing, so an element with number
<code>1</code> is actually the second element)</i>
</p>
<p>
</p><p></p><h3>Implementation details</h3><p></p><p></p><p>Constraints in Artistoo are implemented as separate classes, of which an instance
can be added to a <a href="./manual/../class/src/models/CPM.js~CPM.html">CPM model</a> 
(See <a href="#adding-constraints">above</a> for an explanation how). The base
<a href="./manual/../class/src/hamiltonian/Constraint.js~Constraint.html"><code>Constraint</code></a>
class underlies all of them, and has two subclasses:  <a href="./manual/../class/src/hamiltonian/SoftConstraint.js~SoftConstraint.html"><code>SoftConstraint</code></a> and
<a href="./manual/../class/src/hamiltonian/HardConstraint.js~HardConstraint.html"><code>HardConstraint</code></a>.
These are never used by themselves, but can be extended to create a constraint
(see also <a href="./manual/./custommodules.html">this tutorial</a> to see how to develop custom modules).

</p>
<p>
</p></div>
        <a data-ice="link" href="manual/addConstraints.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Configuring Simulations (2)</h1>
<p>
</p><p></p><p>
In the <a href="./manual/./simulationConfig.html">previous tutorial on configuring simulations</a>, 
we have discussed how you can customize some parts of the simulation directly by
modifying the <code>config</code> object. However, you may wish to have more extensive
customization options that are not possible through configuration only. The
<a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a> 
therefore contains the option of overwriting some of its methods. This allows you to
customize some of them without requiring you to implement everything from scratch.
</p>
<p>
</p><p></p><p>
In this tutorial, we will discuss how to use this option to customize different aspects
of your simulation -- including grid initialization, drawing of the grid, computing
statistics, or adding additional biological processes such as production and diffusion
of soluble molecules, cell proliferation, or cell death.

</p>
<p>
</p><p></p><h3>Overwriting methods</h3><p></p><p></p><p>To see how you can overwrite methods, consider the code from an <a href="./manual/./quickstart.html">
earlier tutorial</a>:

<pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    ...
}
let sim
function initialize(){
    sim = new CPM.Simulation( config )
    step()
}
function step(){
    sim.step()
    requestAnimationFrame( step )
}</code>
</code></pre>


</p>
<p>(Here, note that the <code>...</code> inside the <code>config</code> object should 
be replaced by its normal properties, but its contents are left out here for brevity.
Have a look at this <a href="./manual/./simulationConfig.html">previous tutorial</a>)
</p>
<p>
</p><p></p><p>Now suppose that we want to overwrite the <code>initializeGrid</code> method.
Normally, this method seeds the first cell at the midpoint of the grid, and then seeds
any other cells at random locations. If we want more control over the location of cells
on our grid, we can overwrite this method. We can do this by adapting the code as follows:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    ...
}
let sim
function initialize(){
    let custommethods = {
         initializeGrid : initializeGrid
     }
    sim = new CPM.Simulation( config, custommethods )
    step()
}
function step(){
    sim.step()
    requestAnimationFrame( step )
}
function initializeGrid(){
    // own initialization code here
}</code>
</code></pre>


</p>
<p>
</p><p>There are two changes here. In the <code>initialze()</code> function, we now define
an object <code>custommethods</code> which contains a key (before the colon) for the 
methods we want to overwrite, and a value (after the colon) specifying which function we
want to overwrite them with. We then pass this object along when we initialize the
simulation (<code> sim = new CPM.Simulation(...)</code>). Since we have said here that
we are going to replace the <code>initializeGrid</code> function of the Simulation class,
we must also define its replacement somewhere in the code. That happens at the bottom of
the above code fragment, where we define a new function <code>initializeGrid</code>.
(Currently, this method is empty, so if you would run this code you would just see an 
empty grid. We&apos;ll discuss below what you might want to put inside this replacement
function). 
</p>
<p>
</p><p></p><p>The <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a>
contains the following methods that you may wish to overwrite for your custom simulation:
</p>
<p>
</p><p><ul>
    <li><code>initializeGrid</code>, overwrite this if you want more control over where
    cells are placed, or if you want to add other objects/obstacles to the grid. See
    below for examples;</li>
    <li><code>drawCanvas</code>, overwrite this if you want more control over the
    visualization of your grid;</li>
    <li><code>drawBelow</code> and <code>drawOnTop</code>, use this if you do want to use
    the default visualization methods from <code>drawCanvas</code>, but <i>also</i> want
    to draw something else either below or on top;</li>
    <li><code>logStats</code>, use if you want to log something other than cell centroids
    to the console during your simulation;</li>
    <li><code>postMCSListener</code>, use to add other processes (cell death, proliferation,
    production/diffusion of chemokines, ...) to your simulation.
</li></ul>


</p>
<p>
</p><p>We will now discuss use cases for each of these methods below.</p><p></p><p></p><h3>Custom initialization</h3><p></p><p></p><p>As mentioned in the example above, we can overwrite the <code>initializeGrid()</code>
method to have more control over how the grid is initialized. For example, the following
example uses this method to seed cells at regularly spaced positions instead of
randomly:
</p>
<p>
</p><p><div>
<iframe src="./manual/asset/Epidermis.html" width="100%" height="280px"> </iframe>
</div>


</p>
<p>
</p><p> This example  overwrites the <code>initializeGrid()</code> method with the following
function:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function initializeGrid(){

    // add the initializer if not already there
    if( !this.helpClasses[&quot;gm&quot;] ){ this.addGridManipulator() }

    // Seed epidermal cell layer
    let step = 12

    for( let i = 1 ; i &lt; this.C.extents[0] ; i += step ){
        for( let j = 1 ; j &lt; this.C.extents[1] ; j += step ){
            this.gm.seedCellAt( 1, [i,j] )
        }
    }
}</code>
</code></pre>


</p>
<p>
</p><p>Note that although we are writing this function in the HTML file, it will be called
<i>from inside the Simulation object</i>. That means we have to refer to the simulation object
as <code>this</code> rather than <code>sim</code> (e.g. <code>this.gm.seedCellAt</code>).
If you attach a method to the Simulation object by adding it to the <code>custommethods</code>,
use <code>this</code>. If you write a function inside your HTML file but don&apos;t attach
it to the Simulation object, use <code>sim</code> (the variable name under which you stored
your simulation).
</p>
<p>
</p><p></p><p>
For full code, have a look at <a href="./manual/./examples/Epidermis.html">this page</a>
(once you are on the page and it has loaded, right click anywhere outside the grid, 
then select &apos;view page source&apos;).
</p>
<p>
</p><p></p><p>Another example is the following, where we overwrite the <code>initializeGrid()</code>
to place microchannel walls:
</p>
<p>
</p><p><div>
<iframe src="./examples/Microchannel.html" width="100%" height="200px"> </iframe>
</div>


</p>
<p>
</p><p> The custom functions look like this: </p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function initializeGrid(){

        // add the initializer if not already there
        if( !this.helpClasses[&quot;gm&quot;] ){ this.addGridManipulator() }

        let nrcells = this.conf[&quot;NRCELLS&quot;], cellkind, i
        this.buildChannel()

        // Seed the right number of cells for each cellkind
        for( cellkind = 0; cellkind &lt; nrcells.length; cellkind ++ ){

            for( i = 0; i &lt; nrcells[cellkind]; i++ ){
                // first cell always at the midpoint. Any other cells
                // randomly.<br>                if( i == 0 ){
                    this.gm.seedCellAt( cellkind+1, this.C.midpoint )
                } else {
                    this.gm.seedCell( cellkind+1 )
                }
            }
        }
}

function buildChannel(){


        this.channelvoxels = this.gm.makePlane( [], 1, 0 )
        let gridheight = this.C.extents[1]
        this.channelvoxels = this.gm.makePlane( this.channelvoxels, 1, gridheight-1 )

        this.C.add( new CPM.BorderConstraint({
            BARRIER_VOXELS : this.channelvoxels
        }) )

}</code>
</code></pre>


</p>
<p>
</p><p>This is pretty much the default <code>initializeGrid</code> code, except that it now
calls a new function <code>this.buildChannel</code> first. That means that also the
<code>buildChannel</code> method has to be defined, and passed along to the simulation
object when you define the <code>custommethods</code> inside the <code>initialize()</code>
function:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let custommethods = {
         initializeGrid : initializeGrid,
         buildChannel : buildChannel
     }</code>
</code></pre>


</p>
<p><b>Important note</b>
</p><p><i>Note that the <code>simsettings</code> object inside the <code>config</code> object
contains a property <code>NRCELLS</code>. This is an array that specifies how many cells
of each type of cell have to be seeded on the grid. Normally, this is used by the
<code>initializeGrid()</code> function of the Simulation class. If you overwrite this 
function and don&apos;t use the <code>NRCELLS</code> inside your replacement code, the values
you enter there will no longer influence the number of cells you get on the grid.
However, <b>you must still have the <code>NRCELLS</code> inside your <code>simsettings</code>
object!</b>. This property is used by other methods to know how many cells are on the grid,
and these methods will crash if you don&apos;t have this array. So while its values may not matter, you
must still ensure that an array of the right length (one element per non-background kind
of cell on the grid) is present. </i>
</p>
<p>
</p><h3>Custom visualization</h3><p></p><p></p><p>Your simulation might also contain custom visualization methods. For example, the 
following <a href="./manual/../examples/ManyCellsPrefDir.html">example</a> uses custom 
visualization to draw a line indicating in which direction each cell is going:
</p>
<p>
</p><p><div>
<iframe src="./examples/ManyCellsPrefDir.html" width="100%" height="550px"> </iframe>
</div>


</p>
<p>
</p><p>It does that by overwriting the <code>drawCanvas()</code> method:</p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function drawCanvas(){

    // This part is the normal drawing function

        // Add the canvas if required
        if( !this.helpClasses[&quot;canvas&quot;] ){ this.addCanvas() }

        // Clear canvas and draw stroma border
        this.Cim.clear( this.conf[&quot;CANVASCOLOR&quot;] )

        // Draw each cellkind appropriately
        let cellcolor=this.conf[&quot;CELLCOLOR&quot;], actcolor=this.conf[&quot;ACTCOLOR&quot;], 
            nrcells=this.conf[&quot;NRCELLS&quot;], cellkind, cellborders = this.conf[&quot;SHOWBORDERS&quot;]
        for( cellkind = 0; cellkind &lt; nrcells.length; cellkind ++ ){

            // draw the cells of each kind in the right color
            if( cellcolor[ cellkind ] != -1 ){
                this.Cim.drawCells( cellkind+1, cellcolor[cellkind] )
            }

            // Draw borders if required
            if(  cellborders[ cellkind  ]  ){
                this.Cim.drawCellBorders( cellkind+1, &quot;000000&quot; )
            }
        }

    // This part is for drawing the preferred directions 
    let pdc = this.C.getConstraint( &quot;PersistenceConstraint&quot; )
        let ctx = this.Cim.context(), zoom = this.conf[&quot;zoom&quot;]
        let prefdir = ( pdc.conf[&quot;LAMBDA_DIR&quot;][ cellkind+1 ] &gt; 0  ) || false
        ctx.beginPath()
        ctx.lineWidth = 2*zoom

        for( let i of this.C.cellIDs() ){

            // Only draw for cells that have a preferred direction.
            //if( i == 0 ) continue
            prefdir = ( pdc.conf[&quot;LAMBDA_DIR&quot;][ this.C.cellKind( i ) ] &gt; 0  ) || false
            if( !prefdir ) continue

            ctx.moveTo( 
                pdc.cellcentroidlists[i][0][0]*zoom,
                pdc.cellcentroidlists[i][0][1]*zoom,
                   )
            ctx.lineTo( (pdc.cellcentroidlists[i][0][0]+.1*pdc.celldirections[i][0])*zoom,
                (pdc.cellcentroidlists[i][0][1]+.1*pdc.celldirections[i][1])*zoom,
                   )
        }
        ctx.stroke()<br>}</code>
</code></pre>



</p>
<p>
</p><p>Since only the second part of this method is actually new, we could also have just
replaced the <code>drawOnTop</code> method (which is empty by default).
</p>
<p>
</p><p><b>Exercise:</b></p><p><i>Open the <code>artistoo/examples/html/ManyCellsPrefDir.html</code> example in your
favourite text editor, and try if you can do the same by overwriting <code>drawOnTop</code>
rather than <code>drawCanvas</code>.</i>
</p>
<p>
</p><p>Another example is the <a href="./manual/./examples/Microchannel.html">microchannel</a>, 
where we use the <code>drawBelow()</code> method
to draw the microchannel walls before drawing the other cells:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function drawBelow(){
    this.Cim.drawPixelSet( this.channelvoxels, &quot;AAAAAA&quot; ) 
}</code>
</code></pre>


</p>
<p>
</p><p>That yields the following:</p><p></p><p><div>
<iframe src="./examples/Microchannel.html" width="100%" height="200px"> </iframe>
</div>


</p>
<p>
</p><p>Have a look at the <a href="./manual/../class/src/Canvas.js~Canvas.html"><code>Canvas</code> class</a> for 
an overview of drawing methods you can use in your custom visualizations. This class
uses the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API">
canvas framework</a>, with a syntax you can also use to define your own methods
(for example, we did that to draw the lines in the first example of this section;
have a look at <a href="https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API/Tutorial/Drawing_shapes">
this tutorial</a>).
</p>
<p>
</p><p></p><h3>Custom logging</h3><p></p><p></p><p>Artistoo&apos;s default is to log every cell&apos;s ID, cell kind, and centroid (along with the
system time in MCS). Sometimes, you may wish to log other statistics. Consider the following
example simulation:
</p>
<p>
</p><p><div>
<iframe src="./examples/CellDivision.html" width="100%" height="600px"> </iframe>
</div>


</p>
<p>
</p><p>Suppose we just want to log the total number of cells on the grid every time. We can do
this by overwriting the <code>logStats()</code> method:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function logStats(){

    // count the cell IDs currently on the grid:
    let nrcells = 0
    for( let i of this.C.cellIDs() ){
        nrcells++
    }

    console.log( this.time + &quot;\t&quot; + nrcells )

}</code>
</code></pre>




</p>
<p>
</p><h3>Adding biological processes</h3><p></p><p></p><p>Finally, we may wish to do other stuff in between the CPM steps. For example, the
cell division example above allows cells to proliferate between steps. For this,
the <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a> 
contains an (empty) function called the <code>postMCSListener()</code>, which can be
overwritten. This function is called after every step. By default, it does nothing, but
you can overwrite it with processes you wish to perform. For example, the cell division
example uses it to let cells proliferate:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function postMCSListener(){

        // methods for cell seeding and division are in the GridManipulator class, which
        // is added to the simulation like this:
        if( !this.helpClasses[&quot;gm&quot;] ){ this.addGridManipulator() }

        // Loop over all the cells and let them proliferate with some probability, 
        // but only if their volume is at least 95% of their target volume
        for( let i of this.C.cellIDs() ){
            if( this.C.getVolume(i) &gt; this.C.conf.V[1]*0.95 &amp;&amp; this.C.random() &lt; 0.01 ){
                this.gm.divideCell(i)
            }
        }
}</code>
</code></pre>


</p>
<p>
</p><p>Also have a look at the <a href="./manual/../examples/CancerInvasion.html">cancer invasion
</a> and <a href="./manual/../examples/Chemotaxis.html">chemotaxis</a> examples to see what
you can do with the <code>postMCSListener()</code>.
</p>
<p>
</p></div>
        <a data-ice="link" href="manual/simulationConfig2.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Sharing Your Simulations</h1>
<p>
</p><p></p><p>
This tutorial will describe how you can share your simulations in a zero-install setting.
Note that this tutorial applies to the browser (HTML) simulations only, since command line
(node) simulations <i>do</i> require installation of libraries and are therefore not
zero-install.

</p>
<p>
</p><p></p><h3>Step 1: Create a self-contained directory</h3><p></p><p></p><p>For sharing, we will make a directory that contains all required components. Anyone
who has that folder and opens your simulation in that folder will be able to see your
model in its full glory, as long as they don&apos;t mess with the directory structure or 
move/remove any files.
</p>
<p>
</p><p></p><p>Assuming you have created an empty directory <code>mySimulation</code>, now add the
following files to it:
</p>
<p>
</p><p><ul>
    <li><code>MySimulation.html</code>, the html file containing your simulation;</li>
    <li><code>artistoo.js</code>, the script with the Artistoo code (don&apos;t just make a
    link, but actually copy the code into this folder);</li>
</ul>


</p>
<p>
</p><p>If you&apos;re using the <code>fpsmeter</code>, you also need to add the 
<code>fpsmeter.min.js</code> file from <a href="./manual/../examples/fpsmeter.min.js">here</a>
(the same goes for any other scripts you are loading from your HTML file). 
</p>
<p>
</p><p></p><h3>Step 2: Adjust relative paths</h3><p></p><p></p><p>In your HTML file <code>MySimulation.html</code>, adjust any paths to scripts you
are loading so that they refer to the local copy in your self-contained folder.
To check that it all works, open the HTML file in your browser -- the simulation should
run. If it doesn&apos;t, right click, select &apos;inspect&apos; &gt; &apos;console&apos; to see any error messages
that come up (if your simulation worked before you moved it, any error messages are
probably due to a missing file or a path that needs updating).

</p>
<p>
</p><p></p><p>Just to be sure, move the directory to some other place on your computer and check if
the simulation still runs. If it does, you&apos;re good to go.
</p>
<p>
</p><p></p><h3>Step 3: Share</h3><p></p><p></p><p>Once you have a working simulation in a self-contained directory, you can zip that
directory and send it to someone else. They can unpack the folder on their own computer
and double click the HTML file to run in their own browser. Alternatively, you can
copy the folder to your own server and make your simulation available via a URL.
</p>
<p>
</p></div>
        <a data-ice="link" href="manual/sharingSimulations.html"></a>
      </div>
    </div>
<div class="manual-card-wrap" data-ice="cards">
      <div class="manual-card">
        <div data-ice="card"><h1>Custom Modules</h1>
<p>
</p><p></p><p>
This tutorial will show you how to extend the Artistoo code with your
own custom modules. More detailed information will follow in a later
version of this manual, but for now we will show some examples of how
you can develop your own custom stats. You can use the same principle
to develop your own CPM energy constraints, or even grids (tutorials 
will follow later).

</p>
<p>
</p><p></p><h3>A custom statistic</h3><p></p><p></p><p>In this tutorial, we will implement a custom 
<a href="./manual/../class/src/stats/Stat.js~Stat.html">statistic</a> as an example of a 
custom module. Suppose that in the ActModel example, we want to 
record the percentage of the cell&apos;s pixels that have a non-zero activity.
Since no such statistic currently exists in Artistoo, we&apos;ll have to develop
a custom module. 
</p>
<p>
</p><p></p><p>We&apos;ll build a simulation of a single migrating cell as in the following example:</p><p></p><p><iframe src="./examples/ActModel.html" width="100%" height="400px"> </iframe>


</p>
<p>
</p><p>We will extend this example with our custom statistic.</p><p></p><p></p><p> We start from the code as written in the example. You can find the full code 
<a href="./manual/../examples/ActModel.html">here</a> (once you follow the link the the simulation,
right click and choose &quot;view page source&quot;),
but focussing on the code between the <code>&lt;script&gt;&lt;/script&gt;</code> tags and leaving
out the details in the <code>config</code> object, the simulation looks something like this:

</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
            ...
    }
}
//    ---------------------------------- 
let sim, meter


function initialize(){
    sim = new CPM.Simulation( config, {} )
    meter = new FPSMeter({left:&quot;auto&quot;, right:&quot;5px&quot;})
    step()
}


function step(){
    sim.step()
    meter.tick()
    requestAnimationFrame( step )
}</code>
</code></pre>


</p>
<p>
</p><p></p><p></p><p></p><h4>Step 1: Create a custom extension of the Stat class</h4><p></p><p></p><p>We can write a custom statistic by coding a new class. In doing so, we will
extend the base <a href="./manual/../class/src/stats/Stat.js~Stat.html">Stat class</a>.
This base class takes care of things like attaching your stat to your model for you,
so you don&apos;t need to worry about that. 
</p>
<p>
</p><p></p><p>To implement a new class in the code, we must add it to the code from step 1:</p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
            ...
    }
}
// --------------------------
let sim, meter


function initialize(){
    sim = new CPM.Simulation( config, {} )
    meter = new FPSMeter({left:&quot;auto&quot;, right:&quot;5px&quot;})
    step()
}

class PercentageActive extends CPM.Stat {

}


function step(){
    sim.step()
    meter.tick()
    requestAnimationFrame( step )
}</code>
</code></pre>


</p>
<p>
</p><p>This will create a new class for a statistic called <code>PercentageActive</code>,
which will behave just like the other stats implemented in Artistoo. This means you can
request its value by using <code>sim.C.getStat( PercentageActive )</code> somewhere,
but we&apos;ll get to that later. For now, let&apos;s focus on what code should go between the now
empty braces.
</p>
<p>
</p><p></p><h4> Step 2: Implement a compute() method </h4><p></p><p></p><p>
Looking at the <a href="./manual/../class/src/stats/Stat.js~Stat.html">documentation for the Stat 
class</a>, we see that the important method is the <code>compute()</code> method. In the
base <code>Stat</code> class, this method throws an error, because it is something that 
should be implemented separately for each stat. Let&apos;s add it inside our new class:

</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">class PercentageActive extends CPM.Stat {
    compute(){
        return 0
    }
}</code>
</code></pre>


</p>
<p>
</p><p>
Our code will no longer throw an error, but it is also not very useful yet. We can have a
look at the code from an existing statistic to see how we can generate some useful output.
Have a look at the <code>compute()</code> method from the <code>Connectedness</code>
statistic (full code <a href="./manual/../file/src/stats/Connectedness.js.html">here</a>):
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">
    // The compute method of Connectedness creates an object with 
    // connectedness of each cell on the grid.
    // @return {CellObject} object with for each cell on the grid
    // a connectedness value. 
    compute(){
        // initialize the object
        let connectedness = { }
        // The this.M.pixels() iterator returns coordinates and cellid for all 
        // non-background pixels on the grid. See the appropriate Grid class for
        // its implementation.
        for( let ci of this.M.cellIDs() ){
            connectedness[ci] = this.connectednessOfCell( ci )
        }
        return connectedness
    }</code>
</code></pre>



</p>
<p>
</p><p>Let&apos;s look at what is happening here. Most statistics we want to compute are actually
properties of individual cells, but we may have more than one of those in our simulation.
This means we must compute the statistic for each cell. Statistics therefore typically 
return an object, where each cell gets its own entry. The key of this entry is the cell&apos;s
<a href="./manual/../typedef/index.html#static-typedef-CellId">cellID</a>, and the value is the 
computed statistic <i>for that cell</i>.

</p>
<p>
</p><p></p><p>In the code above, this is also what happens. We first make the empty object <code>{}</code>,
and then set an entry for each cellID on the grid in the loop. The actual values for each
cell are computed by an additional method in the class called <code>connectednessOfCell()</code>,
which takes the cellID as input argument.
</p>
<p>


</p>
<p>Let&apos;s apply the same structure to our own statistic. We get:
</p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">class PercentageActive extends CPM.Stat {

    computePercentageOfCell( cid ){
        return 0
    }

    compute(){

        // Create an object for the output, then add stat for each cell in the loop.
        let percentages = {}
        for( let cid of this.M.cellIDs() ){
            percentages[cid] = this.computePercentageOfCell( cid )
        }

        return percentages

    }
}</code>
</code></pre>


</p>
<p>
</p><h4> Step 3: Implement a computeForCell() method </h4><p></p><p></p><p>Now, how do we get the method <code>computePercentageOfCell()</code> to return the
correct percentage of active pixels? For that, we need to know two things of each cell:
</p><ol>
    <li>The number of pixels of that cell currently active, and</li>
    <li>The total number of pixels of that cell.</li>
</ol>
<p>If we had those, we could compute the percentage of active pixels like this:
</p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">computePercentageOfCell( cid ){

    // divide by total number of pixels and multiply with 100 to get percentage
    return ( 100 * activePixels / totalPixels )
}</code>
</code></pre>


</p>
<p>
</p><p>To know how many pixels a cell has and how many of those are active, let&apos;s start by
looking at which pixels actually are part of the cell. Luckily, there already is a
statistic called <a href="./manual/../class/src/stats/PixelsByCell.js~PixelsByCell.html">PixelsByCell</a>
which does exactly that. Its return value is an object with a key for each cellID, and
as a value an array with all pixels belonging to that cell (given as an 
<a href="./manual/../typedef/index.html#static-typedef-ArrayCoordinate">ArrayCoordinate</a>).
</p>
<p>
</p><p></p><p>We first note that the length of this array equals the number of pixels belonging to
that cell, which we can use directly inside the code for <code>computePercentageOfCell()</code>:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">computePercentageOfCell( cid ){

    // Get the pixels of each cell:
    // Note that we need the &apos;CPM.&apos; prefix since we&apos;re accessing this from outside.
    const cellpixels = this.M.getStat( CPM.PixelsByCell )

    // Get the array of pixels for this cell
    const current_pixels = cellpixels[cid]

    // The length of this array tells us the number of pixels:
    const totalPixels = current_pixels.length

    // divide by total number of pixels and multiply with 100 to get percentage
    return ( 100 * activePixels / totalPixels )
}</code>
</code></pre>


</p>
<p>
</p><p>Note here that <code>this.M</code> contains the current CPM model which we want to
compute the statistic on. Models have a method <code>getStat</code>, which calls the
<code>compute</code> method of the statistic given as an argument. Since we
are accessing this from outside, we need the &quot;CPM.&quot; prefix.
</p>
<p>
</p><p></p><p>Now, we just need the number of active pixels. We should be able to find that somewhere
in our <a href="./manual/../class/src/hamiltonian/ActivityConstraint.js~ActivityConstraint.html">
ActivityConstraint</a>, since it&apos;s used there to compute the Hamiltonian. We find that 
there is a method <a href="./manual/../class/src/hamiltonian/ActivityConstraint.js~ActivityConstraint.html#instance-method-pxact">
pxact</a> that we can use, which takes the
<a href="./manual/../typedef/index.html#static-typedef-IndexCoordinate">IndexCoordinate</a> of
a pixel as argument and then returns it&apos;s current activity value.
</p>
<p>
</p><p></p><p>Let&apos;s put that information to use. We write:</p><p></p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">computePercentageOfCell( cid ){


        // Get the pixels of each cell:
        // Note that we need the &apos;CPM.&apos; prefix since we&apos;re accessing this from outside.
        const cellpixels = this.M.getStat( CPM.PixelsByCell )

        // Get the array of pixels for this cell
        const current_pixels = cellpixels[cid]

        // The length of this array tells us the number of pixels:
        const totalPixels = current_pixels.length

        // Loop over pixels of the current cell and count the active ones:
        let activePixels = 0
        for( let i = 0; i &lt; current_pixels.length; i++ ){
            // PixelsByCell returns ArrayCoordinates, but we need to convert those
            // to IndexCoordinates to look up the activity using the pxact() method.
            const pos = this.M.grid.p2i( current_pixels[i] )

            // increase the counter if pxact() returns an activity &gt; 0
            if( this.M.getConstraint( &quot;ActivityConstraint&quot; ).pxact( pos ) &gt; 0 ){
                activePixels++
            }
        }

        // divide by total number of pixels and multiply with 100 to get percentage
        return ( 100 * activePixels / totalPixels )

    }</code>
</code></pre>


</p>
<p>
</p><h4>Step 4 (Optional): clean-up </h4><p></p><p></p><p>Note: we now compute the <code>PixelsByCell</code> every time the 
<code>computePercentageOfCell</code> method is called, even though it is one single
object with pixels for all cells already in there. Ideally, we&apos;d therefore only call
it once. We clean up the code to compute <code>PixelsByCell</code> at the beginning
of the <code>compute</code>method, and get the following complete code for the new class:
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">class PercentageActive extends CPM.Stat {

    computePercentageOfCell( cid, cellpixels ){

        // Get the array of pixels for this cell
        const current_pixels = cellpixels[cid]

        // The length of this array tells us the number of pixels:
        const totalPixels = current_pixels.length

        // Loop over pixels of the current cell and count the active ones:
        let activePixels = 0
        for( let i = 0; i &lt; current_pixels.length; i++ ){
            // PixelsByCell returns ArrayCoordinates, but we need to convert those
            // to IndexCoordinates to look up the activity using the pxact() method.
            const pos = this.M.grid.p2i( current_pixels[i] )

            // increase the counter if pxact() returns an activity &gt; 0
            if( this.M.getConstraint( &quot;ActivityConstraint&quot; ).pxact( pos ) &gt; 0 ){
                activePixels++
            }
        }

        // divide by total number of pixels and multiply with 100 to get percentage
        return ( 100 * activePixels / totalPixels )

    }

    compute(){
        // Get object with arrays of pixels for each cell on the grid, and get
        // the array for the current cell.
        const cellpixels = this.M.getStat( CPM.PixelsByCell ) 

        // Create an object for the output, then add stat for each cell in the loop.
        let percentages = {}
        for( let cid of this.M.cellIDs() ){
            percentages[cid] = this.computePercentageOfCell( cid, cellpixels )
        }

        return percentages

    }
}</code>
</code></pre>



</p>
<p>
</p><p><i>Note: In the current implementation of statistics in Artistoo this is not 
really necessary, since statistics are actually cached when they are computed. Even if 
the method is called many times, the stat is only computed once unless the grid changes.
But let&apos;s do the cleanup step anyway since it is clearer from the code that way that the 
object will only be computed once.</i>
</p>
<p>
</p><p></p><p>We now have a custom statistic class that we can use. All that&apos;s left now is to make
sure that this statistic is actually computed and reported somewhere in our simulation.
</p>
<p>
</p><p></p><h4>Step 5: Use statistic</h4><p></p><p>To use our new statistic, we will overwrite the <code>logStats()</code> method of
the <a href="./manual/../class/src/simulation/Simulation.js~Simulation.html">Simulation class</a>. 
Rather than reporting the centroids as is done by default, we now log the percentage 
active pixels as returned by our new stat: 
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">function logStats() {
        // compute percentages for all cells
        const allpercentages = this.C.getStat( PercentageActive )

        for( let cid of this.C.cellIDs() ){

            let theperc = allpercentages[cid]

            console.log( this.time + &quot;\t&quot; + cid + &quot;\t&quot; + 
                this.C.cellKind(cid) + &quot;\t&quot; + theperc )

        }

}</code>
</code></pre>


</p>
<p>
</p><p>The full code becomes (where we pass our new <code>logStats</code> method along when
we construct our simulation):
</p>
<p>
</p><p><pre><code class="lang-$xslt"><code class="source-code prettyprint">let config = {
    field_size : [200,200],
        conf : {
        torus : [true,true],<br>        seed : 1,<br>        T : 10,<br>        J: [[0,10], [10,0]],
        LAMBDA_V: [0,5],<br>        V: [0,500],
        LAMBDA_P: [0,2],<br>        P : [0,260],<br>        LAMBDA_ACT : [0,300],<br>        MAX_ACT : [0,30],<br>        ACT_MEAN : &quot;geometric&quot;<br>    },
    simsettings : {
        NRCELLS : [1],<br>        BURNIN : 500,
        RUNTIME : 1000,
        CANVASCOLOR : &quot;eaecef&quot;,
        CELLCOLOR : [&quot;000000&quot;],
        ACTCOLOR : [true],<br>        SHOWBORDERS : [false],<br>        zoom :2,
        SAVEIMG : false,

        // Note that we set this to true for the browser to see the
        // effect of our new stat:

        STATSOUT : { browser: true, node: true },
        LOGRATE : 10<br>
    }
}

let sim, meter


function initialize(){
    // our simulation gets the new logStats method to overwrite the old one:
    sim = new CPM.Simulation( config, { logStats: logStats } )
    meter = new FPSMeter({left:&quot;auto&quot;, right:&quot;5px&quot;})
    step()
}

class PercentageActive extends CPM.Stat {
    computePercentageOfCell( cid, cellpixels ){

        const current_pixels = cellpixels[cid]
        const totalPixels = current_pixels.length

        let activePixels = 0
        for( let i = 0; i &lt; current_pixels.length; i++ ){
            const pos = this.M.grid.p2i( current_pixels[i] )
            if( this.M.getConstraint( &quot;ActivityConstraint&quot; ).pxact( pos ) &gt; 0 ){
                activePixels++
            }
        }

        return ( 100 * activePixels / totalPixels )
    }

    compute(){
        const cellpixels = this.M.getStat( CPM.PixelsByCell ) 
        let percentages = {}
        for( let cid of this.M.cellIDs() ){
            percentages[cid] = this.computePercentageOfCell( cid, cellpixels )
        }
        return percentages
    }
}

function logStats() {
        const allpercentages = this.C.getStat( PercentageActive )
        for( let cid of this.C.cellIDs() ){
            let theperc = allpercentages[cid]
            console.log( this.time + &quot;\t&quot; + cid + &quot;\t&quot; + 
                this.C.cellKind(cid) + &quot;\t&quot; + theperc )
        }
}

function step(){
    sim.step()
    meter.tick()
    requestAnimationFrame( step )
}</code>
</code></pre>



</p>
<p>
</p><p>The end result is this (right click inside the simulation, choose &apos;inspect&apos; and then
&apos;console&apos; to see the output):
</p>
<p>
</p><p><iframe src="./examples/ActModelCustomStat.html" width="100%" height="400px"> </iframe>



</p>
<p>
</p><h3>A custom constraint</h3><p></p><p></p><p>Just like you might want to develop a custom statistic, you might also want to develop
your own model constraints. A detailed tutorial will follow, but for now, you can try
applying the same principle as described above for the statistics. But instead of the
<a href="./manual/../class/src/stats/Stat.js~Stat.html"><code>Stat</code> class</a>, you will
have to extend either the <a href="./manual/../class/src/hamiltonian/SoftConstraint.js~SoftConstraint.html"><code>SoftConstraint</code></a> or
the <a href="./manual/../class/src/hamiltonian/HardConstraint.js~HardConstraint.html"><code>HardConstraint</code></a>
class (see also <a href="./manual/./addConstraints.html">this tutorial</a> for more information).
Have a look at their code <a href="./manual/../file/src/hamiltonian/SoftConstraint.js.html">here</a> 
and <a href="./manual/../file/src/hamiltonian/HardConstraint.js.html">here</a> to see which methods
your class extension will have to overwrite. Of course, you can have a look at the code
for one of the <a href="./manual/../file/src/hamiltonian/ActivityConstraint.js.html">existing constraints</a> 
for inspiration as well. Once you have written your constraint inside your simulation file
as explained for the custom statistics above, you can add it using the 
 <a href="./manual/../class/src/models/CPM.js~CPM.html#instance-method-add"><code>add()</code> 
 method</a> as explained <a href="./manual/./addConstraints.html#method-2-add">here</a>.

</p>
<p>
</p></div>
        <a data-ice="link" href="manual/custommodules.html"></a>
      </div>
    </div>
</div>
</div>
</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
